// Generated by jextract

package org.chdb.ffm;

import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.MemoryLayout.PathElement.*;
import static java.lang.foreign.ValueLayout.*;

/**
 * {@snippet lang = c:
 * struct local_result_v2 {
 *     char *buf;
 *     size_t len;
 *     void *_vec;
 *     double elapsed;
 *     uint64_t rows_read;
 *     uint64_t bytes_read;
 *     char *error_message;
 * }
 *}
 */
public class local_result_v2 {

    local_result_v2() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            LibChdb.C_POINTER.withName("buf"),
            LibChdb.C_LONG.withName("len"),
            LibChdb.C_POINTER.withName("_vec"),
            LibChdb.C_DOUBLE.withName("elapsed"),
            LibChdb.C_LONG_LONG.withName("rows_read"),
            LibChdb.C_LONG_LONG.withName("bytes_read"),
            LibChdb.C_POINTER.withName("error_message")
    ).withName("local_result_v2");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout buf$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("buf"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * char *buf
     *}
     */
    public static final AddressLayout buf$layout() {
        return buf$LAYOUT;
    }

    private static final long buf$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * char *buf
     *}
     */
    public static final long buf$offset() {
        return buf$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * char *buf
     *}
     */
    public static MemorySegment buf(MemorySegment struct) {
        return struct.get(buf$LAYOUT, buf$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * char *buf
     *}
     */
    public static void buf(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(buf$LAYOUT, buf$OFFSET, fieldValue);
    }

    private static final OfLong len$LAYOUT = (OfLong) $LAYOUT.select(groupElement("len"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * size_t len
     *}
     */
    public static final OfLong len$layout() {
        return len$LAYOUT;
    }

    private static final long len$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * size_t len
     *}
     */
    public static final long len$offset() {
        return len$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * size_t len
     *}
     */
    public static long len(MemorySegment struct) {
        return struct.get(len$LAYOUT, len$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * size_t len
     *}
     */
    public static void len(MemorySegment struct, long fieldValue) {
        struct.set(len$LAYOUT, len$OFFSET, fieldValue);
    }

    private static final AddressLayout _vec$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("_vec"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * void *_vec
     *}
     */
    public static final AddressLayout _vec$layout() {
        return _vec$LAYOUT;
    }

    private static final long _vec$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * void *_vec
     *}
     */
    public static final long _vec$offset() {
        return _vec$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * void *_vec
     *}
     */
    public static MemorySegment _vec(MemorySegment struct) {
        return struct.get(_vec$LAYOUT, _vec$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * void *_vec
     *}
     */
    public static void _vec(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_vec$LAYOUT, _vec$OFFSET, fieldValue);
    }

    private static final OfDouble elapsed$LAYOUT = (OfDouble) $LAYOUT.select(groupElement("elapsed"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * double elapsed
     *}
     */
    public static final OfDouble elapsed$layout() {
        return elapsed$LAYOUT;
    }

    private static final long elapsed$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * double elapsed
     *}
     */
    public static final long elapsed$offset() {
        return elapsed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * double elapsed
     *}
     */
    public static double elapsed(MemorySegment struct) {
        return struct.get(elapsed$LAYOUT, elapsed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * double elapsed
     *}
     */
    public static void elapsed(MemorySegment struct, double fieldValue) {
        struct.set(elapsed$LAYOUT, elapsed$OFFSET, fieldValue);
    }

    private static final OfLong rows_read$LAYOUT = (OfLong) $LAYOUT.select(groupElement("rows_read"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * uint64_t rows_read
     *}
     */
    public static final OfLong rows_read$layout() {
        return rows_read$LAYOUT;
    }

    private static final long rows_read$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * uint64_t rows_read
     *}
     */
    public static final long rows_read$offset() {
        return rows_read$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * uint64_t rows_read
     *}
     */
    public static long rows_read(MemorySegment struct) {
        return struct.get(rows_read$LAYOUT, rows_read$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * uint64_t rows_read
     *}
     */
    public static void rows_read(MemorySegment struct, long fieldValue) {
        struct.set(rows_read$LAYOUT, rows_read$OFFSET, fieldValue);
    }

    private static final OfLong bytes_read$LAYOUT = (OfLong) $LAYOUT.select(groupElement("bytes_read"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * uint64_t bytes_read
     *}
     */
    public static final OfLong bytes_read$layout() {
        return bytes_read$LAYOUT;
    }

    private static final long bytes_read$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * uint64_t bytes_read
     *}
     */
    public static final long bytes_read$offset() {
        return bytes_read$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * uint64_t bytes_read
     *}
     */
    public static long bytes_read(MemorySegment struct) {
        return struct.get(bytes_read$LAYOUT, bytes_read$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * uint64_t bytes_read
     *}
     */
    public static void bytes_read(MemorySegment struct, long fieldValue) {
        struct.set(bytes_read$LAYOUT, bytes_read$OFFSET, fieldValue);
    }

    private static final AddressLayout error_message$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("error_message"));

    /**
     * Layout for field:
     * {@snippet lang = c:
     * char *error_message
     *}
     */
    public static final AddressLayout error_message$layout() {
        return error_message$LAYOUT;
    }

    private static final long error_message$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang = c:
     * char *error_message
     *}
     */
    public static final long error_message$offset() {
        return error_message$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang = c:
     * char *error_message
     *}
     */
    public static MemorySegment error_message(MemorySegment struct) {
        return struct.get(error_message$LAYOUT, error_message$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang = c:
     * char *error_message
     *}
     */
    public static void error_message(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(error_message$LAYOUT, error_message$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() {
        return layout().byteSize();
    }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

